// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: logistic_centers.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/gofrs/uuid"
)

const countLogisticCenters = `-- name: CountLogisticCenters :one
SELECT count(*)
FROM   im.logistic_centers
`

func (q *Queries) CountLogisticCenters(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLogisticCenters)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLogisticCenter = `-- name: CreateLogisticCenter :one
INSERT INTO im.logistic_centers
    (logistic_center_name)
VALUES
    ($1)
RETURNING id, logistic_center_name, created_at, updated_at
`

func (q *Queries) CreateLogisticCenter(ctx context.Context, logisticCenterName string) (ImLogisticCenter, error) {
	row := q.db.QueryRowContext(ctx, createLogisticCenter, logisticCenterName)
	var i ImLogisticCenter
	err := row.Scan(
		&i.ID,
		&i.LogisticCenterName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLogisticCenter = `-- name: DeleteLogisticCenter :exec
DELETE FROM im.logistic_centers
WHERE  id = $1
`

func (q *Queries) DeleteLogisticCenter(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteLogisticCenter, id)
	return err
}

const getAllLogisticCenters = `-- name: GetAllLogisticCenters :many
WITH warehouses AS
         (
             SELECT s.logistic_center_id as logisticCenterId,
                    jsonb_build_object(
                            'warehouse_id',s.id,
                            'warehouse_name', s.warehouse_name,
                            'locations',  COALESCE(
                                            jsonb_agg(
                                            jsonb_build_object(
                                                    'location_id', c.id,
                                                    'location_name', c.location_name
                                                ))
                                            FILTER (WHERE c.id IS NOT NULL),'[]')
                        ) AS warehouses_list
             FROM im.warehouses AS s
                      FULL OUTER JOIN im.locations AS c
                                      ON c.warehouse_id = s.id
             GROUP BY s.id,s.warehouse_name
         )
SELECT jsonb_build_object(
               'logistic_center_id', logCen.id,
               'logistic_center_name', logCen.logistic_center_name,
               'warehouses', COALESCE(json_agg(w.warehouses_list) FILTER ( WHERE w.warehouses_list IS NOT NULL),'[]')
           )
FROM warehouses AS w
         FULL JOIN im.logistic_centers AS logCen
                   ON logCen.id = w.logisticCenterId
GROUP BY logCen.logistic_center_name,logCen.id
ORDER BY logCen.created_at DESC
`

func (q *Queries) GetAllLogisticCenters(ctx context.Context) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getAllLogisticCenters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var jsonb_build_object json.RawMessage
		if err := rows.Scan(&jsonb_build_object); err != nil {
			return nil, err
		}
		items = append(items, jsonb_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogisticCenterById = `-- name: GetLogisticCenterById :one
WITH warehouses AS
         (
             SELECT s.logistic_center_id as logisticCenterId,
                    jsonb_build_object(
                            'warehouse_id',s.id,
                            'warehouse_name', s.warehouse_name,
                            'locations',  COALESCE(
                                            jsonb_agg(
                                            jsonb_build_object(
                                                    'location_id', c.id,
                                                    'location_name', c.location_name
                                                ))
                                            FILTER (WHERE c.id IS NOT NULL),'[]')
                        ) AS warehouses_list
             FROM im.warehouses AS s
                      FULL OUTER JOIN im.locations AS c
                                      ON c.warehouse_id = s.id
             GROUP BY s.id,s.warehouse_name
         )
SELECT jsonb_build_object(
               'logistic_center_id', logCen.id,
               'logistic_center_name', logCen.logistic_center_name,
               'warehouses', COALESCE(json_agg(w.warehouses_list) FILTER ( WHERE w.warehouses_list IS NOT NULL),'[]')
           )
FROM warehouses AS w
         FULL JOIN im.logistic_centers AS logCen
                   ON logCen.id = w.logisticCenterId
WHERE logCen.id=$1
GROUP BY logCen.logistic_center_name,logCen.id
`

func (q *Queries) GetLogisticCenterById(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getLogisticCenterById, id)
	var jsonb_build_object json.RawMessage
	err := row.Scan(&jsonb_build_object)
	return jsonb_build_object, err
}

const getLogisticCenterByName = `-- name: GetLogisticCenterByName :one
SELECT id, logistic_center_name, created_at, updated_at FROM im.logistic_centers lc WHERE lc.logistic_center_name=$1 LIMIT 1
`

func (q *Queries) GetLogisticCenterByName(ctx context.Context, logisticCenterName string) (ImLogisticCenter, error) {
	row := q.db.QueryRowContext(ctx, getLogisticCenterByName, logisticCenterName)
	var i ImLogisticCenter
	err := row.Scan(
		&i.ID,
		&i.LogisticCenterName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLogisticCentersWithPagination = `-- name: GetLogisticCentersWithPagination :many
WITH warehouses AS
         (
             SELECT s.logistic_center_id as logisticCenterId,
                    jsonb_build_object(
                            'warehouse_id',s.id,
                            'warehouse_name', s.warehouse_name,
                            'locations',  COALESCE(
                                            jsonb_agg(
                                            jsonb_build_object(
                                                    'location_id', c.id,
                                                    'location_name', c.location_name
                                                ))
                                            FILTER (WHERE c.id IS NOT NULL),'[]')
                        ) AS warehouses_list
             FROM im.warehouses AS s
                      FULL OUTER JOIN im.locations AS c
                                      ON c.warehouse_id = s.id
             GROUP BY s.id,s.warehouse_name
         )
SELECT jsonb_build_object(
               'logistic_center_id', logCen.id,
               'logistic_center_name', logCen.logistic_center_name,
               'warehouses', COALESCE(json_agg(w.warehouses_list) FILTER ( WHERE w.warehouses_list IS NOT NULL),'[]')
           )
FROM warehouses AS w
         FULL JOIN im.logistic_centers AS logCen
                   ON logCen.id = w.logisticCenterId
GROUP BY logCen.logistic_center_name,logCen.id
ORDER BY logCen.created_at DESC
LIMIT $1
OFFSET $2
`

type GetLogisticCentersWithPaginationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetLogisticCentersWithPagination(ctx context.Context, arg GetLogisticCentersWithPaginationParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getLogisticCentersWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var jsonb_build_object json.RawMessage
		if err := rows.Scan(&jsonb_build_object); err != nil {
			return nil, err
		}
		items = append(items, jsonb_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneLogisticCenterData = `-- name: GetOneLogisticCenterData :one
SELECT id, logistic_center_name, created_at, updated_at FROM im.logistic_centers lc WHERE lc.id=$1 LIMIT 1
`

func (q *Queries) GetOneLogisticCenterData(ctx context.Context, id uuid.UUID) (ImLogisticCenter, error) {
	row := q.db.QueryRowContext(ctx, getOneLogisticCenterData, id)
	var i ImLogisticCenter
	err := row.Scan(
		&i.ID,
		&i.LogisticCenterName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLogisticCenter = `-- name: UpdateLogisticCenter :one
UPDATE im.logistic_centers
SET    logistic_center_name=$2
WHERE  id=$1
RETURNING id, logistic_center_name, created_at, updated_at
`

type UpdateLogisticCenterParams struct {
	ID                 uuid.UUID `json:"id"`
	LogisticCenterName string    `json:"logistic_center_name"`
}

func (q *Queries) UpdateLogisticCenter(ctx context.Context, arg UpdateLogisticCenterParams) (ImLogisticCenter, error) {
	row := q.db.QueryRowContext(ctx, updateLogisticCenter, arg.ID, arg.LogisticCenterName)
	var i ImLogisticCenter
	err := row.Scan(
		&i.ID,
		&i.LogisticCenterName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
