// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: locations.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/gofrs/uuid"
)

const countOfLocations = `-- name: CountOfLocations :one
SELECT count(*)
FROM im.locations
`

func (q *Queries) CountOfLocations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOfLocations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO im.locations
    (location_name,warehouse_id)
VALUES
    ($1,$2)
RETURNING id, location_name, warehouse_id, created_at, updated_at
`

type CreateLocationParams struct {
	LocationName string    `json:"location_name"`
	WarehouseID  uuid.UUID `json:"warehouse_id"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (ImLocation, error) {
	row := q.db.QueryRowContext(ctx, createLocation, arg.LocationName, arg.WarehouseID)
	var i ImLocation
	err := row.Scan(
		&i.ID,
		&i.LocationName,
		&i.WarehouseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLocation = `-- name: DeleteLocation :exec
DELETE FROM im.locations
WHERE  id = $1
`

func (q *Queries) DeleteLocation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteLocation, id)
	return err
}

const getLocationById = `-- name: GetLocationById :one
select jsonb_build_object(
               'location_id', a.id,
               'location_name', a.location_name,
               'warehouse', y.warehouse)
from im.locations a
         left join lateral (
    select jsonb_build_object('warehouse_id', w.id, 'warehouse_name', w.warehouse_name) as warehouse
    from im.warehouses w where w.id = a.warehouse_id
    ) as y on true
where a.id = $1
limit 1
`

func (q *Queries) GetLocationById(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getLocationById, id)
	var jsonb_build_object json.RawMessage
	err := row.Scan(&jsonb_build_object)
	return jsonb_build_object, err
}

const getLocationByName = `-- name: GetLocationByName :one
SELECT id, location_name, warehouse_id, created_at, updated_at
FROM im.locations
WHERE location_name = $1
LIMIT 1
`

func (q *Queries) GetLocationByName(ctx context.Context, locationName string) (ImLocation, error) {
	row := q.db.QueryRowContext(ctx, getLocationByName, locationName)
	var i ImLocation
	err := row.Scan(
		&i.ID,
		&i.LocationName,
		&i.WarehouseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLocationByWarehouseId = `-- name: GetLocationByWarehouseId :one
SELECT id, location_name, warehouse_id, created_at, updated_at FROM im.locations l WHERE l.warehouse_id=$1 AND l.location_name ILIKE $2
`

type GetLocationByWarehouseIdParams struct {
	WarehouseID  uuid.UUID `json:"warehouse_id"`
	LocationName string    `json:"location_name"`
}

func (q *Queries) GetLocationByWarehouseId(ctx context.Context, arg GetLocationByWarehouseIdParams) (ImLocation, error) {
	row := q.db.QueryRowContext(ctx, getLocationByWarehouseId, arg.WarehouseID, arg.LocationName)
	var i ImLocation
	err := row.Scan(
		&i.ID,
		&i.LocationName,
		&i.WarehouseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLocations = `-- name: GetLocations :many
select jsonb_build_object(
               'location_id', a.id,
               'location_name', a.location_name,
               'warehouse', y.warehouse)
from im.locations a
         left join lateral (
    select jsonb_build_object('warehouse_id', w.id, 'warehouse_name', w.warehouse_name) as warehouse
    from im.warehouses w where w.id = a.warehouse_id
    ) as y on true
order by a.created_at desc
`

func (q *Queries) GetLocations(ctx context.Context) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var jsonb_build_object json.RawMessage
		if err := rows.Scan(&jsonb_build_object); err != nil {
			return nil, err
		}
		items = append(items, jsonb_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationsWithPagination = `-- name: GetLocationsWithPagination :many
select jsonb_build_object(
               'location_id', a.id,
               'location_name', a.location_name,
               'warehouse', y.warehouse)
from im.locations a
         left join lateral (
    select jsonb_build_object('warehouse_id', w.id, 'warehouse_name', w.warehouse_name) as warehouse
    from im.warehouses w where w.id = a.warehouse_id
    ) as y on true
order by a.created_at desc
limit $1
offset $2
`

type GetLocationsWithPaginationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetLocationsWithPagination(ctx context.Context, arg GetLocationsWithPaginationParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getLocationsWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var jsonb_build_object json.RawMessage
		if err := rows.Scan(&jsonb_build_object); err != nil {
			return nil, err
		}
		items = append(items, jsonb_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneLocation = `-- name: GetOneLocation :one
SELECT id, location_name, warehouse_id, created_at, updated_at FROM im.locations l WHERE l.id=$1
`

func (q *Queries) GetOneLocation(ctx context.Context, id uuid.UUID) (ImLocation, error) {
	row := q.db.QueryRowContext(ctx, getOneLocation, id)
	var i ImLocation
	err := row.Scan(
		&i.ID,
		&i.LocationName,
		&i.WarehouseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLocation = `-- name: UpdateLocation :one
UPDATE im.locations
SET    location_name=$2,
       warehouse_id=$3
WHERE  id=$1
RETURNING id, location_name, warehouse_id, created_at, updated_at
`

type UpdateLocationParams struct {
	ID           uuid.UUID `json:"id"`
	LocationName string    `json:"location_name"`
	WarehouseID  uuid.UUID `json:"warehouse_id"`
}

func (q *Queries) UpdateLocation(ctx context.Context, arg UpdateLocationParams) (ImLocation, error) {
	row := q.db.QueryRowContext(ctx, updateLocation, arg.ID, arg.LocationName, arg.WarehouseID)
	var i ImLocation
	err := row.Scan(
		&i.ID,
		&i.LocationName,
		&i.WarehouseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
